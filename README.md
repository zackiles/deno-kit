# <img src="assets/logo.ico" width="20" height="20" style="vertical-align: middle"> Deno-Kit

<div align="center">

<img src="assets/logo.png" height="350"></img>

[![Deno](https://img.shields.io/badge/Deno-000?logo=deno&logoColor=fff)](https://jsr.io/@deno-kit/kit)
[![JSR Score](https://jsr.io/badges/@deno-kit/kit/score)](https://jsr.io/@deno-kit/kit)
[![JSR](https://jsr.io/badges/@deno-kit/kit)](https://jsr.io/@deno-kit/kit)
[![JSR Scope](https://jsr.io/badges/@deno-kit)](https://jsr.io/@deno-kit)

[![cd](https://github.com/zackiles/deno-kit/actions/workflows/publish-github.yml/badge.svg)](https://github.com/zackiles/deno-kit/actions/workflows/publish-github.yml)

<em>Opinionated scaffolding for the future of AI-native codebases</em><br>

</div>

## Overview

Scaffold and publish modern Typescript projects in seconds with the Deno-Kit CLI. Hyper-optimized for agentic collaborators, with best practices, intelligent defaults, tools for agents, and first-class integration with Cursor, Claude Code, and Windsurf. Read more about its approach to [Context-first Codebases For Agents](#context-first-codebases-for-agents) or some of its [other features](#features).

**Supported Scaffold Types**:<br> `Library`, `CLI`, `HTTP-Server`, `Websocket-Server`, and `MCP-Server`

> [!IMPORTANT]
> **BYOD (Bring Your Own Runtime)**
>
> Deno-Kit focuses specifically on the **foundational** aspects of project configuration, structure, and developer workflows. It is indifferent to your application runtime, along with the frameworks, libraries and patterns you choose to design it with

<!-- TODO: The template is stale. Update zackiles/deno-kit-starter-template. Ideally even just automate its creation in publish-github.yml
> [!TIP]
> **Prefer a Github Template?** Try our opinionated [pre-made starter-template](https://github.com/zackiles/deno-kit-starter-template) configured as a Deno library that already has Deno-Kit and a fully configured and publishable package ready to go, OR read below if you'd prefer a hands-on approach using the Deno-Kit CLI.
-->

## **Quick Start**

### Install

Install the Deno-Kit native binary globally, instantly, and cross-platform so you can use it to bootstrap and manage all your Deno projects:

```sh
curl -fsSL https://raw.githubusercontent.com/zackiles/deno-kit/main/install.sh | sh
```

> [!NOTE]
> To uninstall, run: `deno-kit uninstall`

### Scaffold Your First Project

With deno-kit installed you can scaffold a new project in the current directory:

```sh
deno-kit
```

Or a different directory:

```sh
deno-kit ../new-project
```

üöÄ **That's it!**. You can continue to use the powerful features of Deno-Kit (see a list of tools `deno-kit --help`), or if you made a mistake configuring the project you can reset using `deno-kit reset`. You can completely uninstall it from your system using `deno-kit uninstall`.

> [!TIP]
> You can specify a folder that doesn't exist. Deno-Kit will create it, and change the working directory to it for you automatically

### How Scaffolding Works

**Configures**: from hyper-customized to instant projects, it'll walk you through setting it up. All steps are skippable and have intelligent defaults.<br>

**Generates**: a ready-to-go project with all the bells and whistles: documentation, workflows for testing and releasing, comprehensive configuration for VSCode/Cursor/Github and more, one-step publishing on JSR, and a handful of battle-tested utilities from the `@deno-kit` standard library that compliment and enhance Deno's. It'll even create the repository and push the initial commit up with the Github CLI if you set it to.<br>

> [!NOTE]
> Deno-Kit receives updates. Running `deno kit update` will attempt to update both the CLI _and_ from time-to-time the project scaffolding or shell. If anything goes wrong during an update, you can use `deno-kit reset` to rollback the recent changes.

> [!TIP]
> Done with Deno-Kit? You can remove it completely and any time without harming the project using `deno-kit remove`.

---

## Features

üß≠ **Guided Setup**: Quickly setup your next package with guided setup and intelligent defaults based on your current working environment.

üß© **Multiple Project Types**: CLI, Library, HTTP-Server, WebSocket-Server, MCP-Server.

ü¶ñ **Modern Deno 2**: best practices such as safe defaults for lint/fmt/compile/publish and more, as well as out-of-the-box setup for the latest APIs such as OpenTelemetry.

ü§ñ **AI-Native:** Use Cursor? Deno-kit includes a complete set of Deno-optimized AI triggers, meta prompts, a full suite of Cursor rules in `.cursor/rules`, MCP servers for your codebase in `ai/mcp` and a local index of documentation for AI in `ai/docs` to jump-start your project

üîí **Safe Defaults:** Achieve a 100% [JSR score](https://jsr.io/docs/scoring) with safe defaults and comprehensive TypeScript coverage.

üõ† **Helpful Testing Tools:**
Accelerate development of your next package easily with autogenerated CLI, HTTP, and WebSocket clients to consume and test your package locally.

## Removing Deno-Kit

Removing `deno-kit` wont harm your project, but it WILL remove your ability to use several helpful long-term features such as : automatic publishing github workflows with `deno-kit publish`, hosting your library automatically with and `deno-kit cli` as well as the ability to adopt the latest features and best practices by updating with `deno-kit update`.

## Updating Your Project With Deno Kit

Running `deno-kit update` will update the following:

- Cursor rules in `.cursor/` (Rules documented in [CURSOR-RULES](CURSOR-RULES.md)
- MCP servers for AI in `ai/mcp`
- Docs for AI in `ai/docs`
- Docs for humans in `docs/`
- Update `deno-kit` dependencies
- General enhancements and critical fixes to `deno-kit`

## Prerequisites

- [Deno](https://deno.com/) v2.0 or newer
- **Note:** if you're building a browser-based library you will have to add additional libraries to `compilerOptions.lib` in `deno.jsonc` such as `dom`. For more info see: [DenoDocs - CompilerOptions](https://docs.deno.com/runtime/reference/ts_config_migration/)

---

## Context-first Codebases For Agents

**The self-discovery pattern helps an AI agent fetch just-in-time context.**
Every design choice leaves breadcrumbs that lead the agent to the next relevant file. This cascades context incrementally as the agent navigates common workflows, maintaining coherence and optimal context-window usage.

Self-discovery unfolds through three pillars:

- **Context funnels** that trigger incremental context injection
- **Embedded tools** that surface knowledge on demand
- **Information architecture** tuned for AI navigation

### Funneling

The agent's system prompt automatically injects triggers for incremental context discovery.

**Global prompts** provide structured instructions for context-seeking based on file and folder glob patterns. This establishes the first layer of triggers.

**Glob hierarchies** activate when the agent works on matching files or folders. The global prompt triggers the agent to fetch additional context, which then sets up deeper, more specific triggers.

> **üß™ Example workflow**
>
> An agent tasked with editing tests receives only the system prompt initially:
>
> 1. **First trigger:** "Review the `README.md` before starting."
> 2. **Agent loads README:** Finds instructions for running tests.
> 3. **Agent runs tests:** Output prints the test folder path to terminal.
> 4. **Agent navigates to `test/`:** Glob match triggers documentation review for the testing framework.
> 5. **Agent reads specific test file:** Previous triggers mentioned this file requires fetching file-specific documentation.
> 6. **Agent finishes writing test:** New context instructs them to run tests with a specific command.
> 7. **Tests fail:** Error message contains trigger instructing agent to fetch debugging-specific context.
>
> This demonstrates how lazy-loaded context acts as triggers, enhancing agent coherence across multi-turn conversations.

### Tools

The `.ai` folder equips your agent with actual tools and usage instructions:

- **Automatic repomix snapshots** for lightning-fast semantic search of the entire codebase
- **Purpose-built grep tool** designed specifically for agent workflows
- **Git hooks and Deno tasks** that automatically maintain the lifecycle of code indexes
- **Curated knowledge base** of latest Deno and TypeScript references from official docs, source internals, and GitHub discussions

### Information architecture

Self-discovery requires thoughtful naming and project structure from the start. Strong foundations contribute most to agent coherence as codebases grow.

Every observable element acts as implicit instructions:

- **File and folder names** follow descriptive, predictable patterns
- **Configuration files** include complete schemas and inline comments for autonomy
- **Repeating patterns and terms** reinforce agent behavior through context windows that leverage training data effectively

**Example:** An agent encountering `var` in JavaScript projects will likely write code matching that era's patterns from its training data.

---

<br><p align="center"><b>Made with ‚ù§Ô∏è by humans (mostly)<b></p>
